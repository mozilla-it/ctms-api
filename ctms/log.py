"""Logging configuration"""

import logging
import logging.config
from typing import Dict, List, Optional

import structlog
import uvicorn
from fastapi import Request
from starlette.routing import Match
from structlog.types import Processor


def configure_logging(
    use_mozlog: bool = True, logging_level: str = "INFO", log_sqlalchemy: bool = False
) -> None:
    """Configure Python logging.

    :param use_mozlog: If True, use MozLog format, appropriate for deployments.
        If False, format logs for human consumption.
    :param logging_level: The logging level, such as DEBUG or INFO.
    :param log_sqlalchemy: Include SQLAlchemy engine logs, such as SQL statements
    """
    # Processors used for logs generated by stdlib's logging
    uvicorn_formatters = uvicorn.config.LOGGING_CONFIG["formatters"]

    if use_mozlog:
        structlog_fmt_prep: Processor = structlog.stdlib.render_to_log_kwargs
        structlog_dev_processors: List[Processor] = []
    else:
        structlog_fmt_prep = structlog.stdlib.ProcessorFormatter.wrap_for_formatter
        structlog_dev_processors = [
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
        ]
    logging_config = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "dev_console": {
                "()": structlog.stdlib.ProcessorFormatter,
                "processor": structlog.dev.ConsoleRenderer(colors=True),
                "foreign_pre_chain": structlog_dev_processors,
            },
            "mozlog_json": {
                "()": "dockerflow.logging.JsonLogFormatter",
                "logger_name": "ctms",
            },
            "uvicorn_access": uvicorn_formatters["access"],
            "uvicorn_default": uvicorn_formatters["default"],
        },
        "handlers": {
            "humans": {
                "class": "logging.StreamHandler",
                "formatter": "dev_console",
                "level": "DEBUG",
            },
            "mozlog": {
                "class": "logging.StreamHandler",
                "formatter": "mozlog_json",
                "level": "DEBUG",
            },
            "uvicorn.access": {
                "class": "logging.StreamHandler",
                "formatter": "uvicorn_access",
                "level": "INFO",
            },
            "uvicorn.default": {
                "class": "logging.StreamHandler",
                "formatter": "uvicorn_default",
                "level": "INFO",
            },
        },
        "loggers": {
            "alembic": {
                "propagate": False,
                "handlers": ["mozlog" if use_mozlog else "humans"],
                "level": logging_level,
            },
            "ctms": {
                "propagate": False,
                "handlers": ["mozlog" if use_mozlog else "humans"],
                "level": logging_level,
            },
            "uvicorn": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level,
                "propagate": False,
            },
            "uvicorn.error": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level,
                "propagate": False,
            },
            "uvicorn.access": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.access"],
                "level": "WARNING",  # was INFO, but duplicates ctms.web
                "propagate": False,
            },
            "sqlalchemy.engine": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level if log_sqlalchemy else "WARNING",
                "propagate": False,
            },
        },
        "root": {
            "handlers": ["mozlog" if use_mozlog else "humans"],
            "level": "WARNING",
        },
    }
    logging.config.dictConfig(logging_config)

    structlog_processors: List[Processor] = [structlog.stdlib.filter_by_level]
    structlog_processors.extend(structlog_dev_processors)
    structlog_processors.extend(
        [
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog_fmt_prep,
        ]
    )
    structlog.configure(
        processors=structlog_processors,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )


def context_from_request(request: Request) -> Dict:
    """Extract data from a log request."""
    context = {
        "trivial": False,  # For filtering in papertrail, place early in log
        "client_host": request.client.host,
        "method": request.method,
        "path": request.url.path,
    }

    # Determine the path template, like "/ctms/{email_id}"
    for route in request.app.routes:
        match, _ = route.matches(request.scope)
        if match == Match.FULL:
            context["path_template"] = str(route.path)
            break

    if request.path_params:
        context["path_params"] = request.path_params

    # Process headers, omitting security-sensitive values
    headers = {}
    for header_name, header_value in request.headers.items():
        if header_name in {"cookie", "authorization"}:
            headers[header_name] = "[OMITTED]"
        else:
            headers[header_name] = header_value
    if headers:
        context["headers"] = headers

    # Process queries, removing personally-identifiable info
    query = {}
    for query_name, query_value in request.query_params.items():
        if query_name in {"primary_email", "fxa_primary_email"}:
            query[query_name] = "[OMITTED]"
        else:
            query[query_name] = query_value
    if query:
        context["query"] = query

    return context


def get_log_line(
    request: Request, status_code: int, user_id: Optional[str] = None
) -> str:
    """
    Create a log line for a web request

    This is based on the uvicorn log format, but doesn't match exactly.
    Our log looks uses repr, which surrounds the request line with single quotes:

    172.18.0.1:63750 - 'GET /openapi.json HTTP/1.1' 200

    The uvicorn format uses double quotes:

    172.18.0.1:63750 - "GET /openapi.json HTTP/1.1" 200
    """
    request_line = (
        f"{request.method} {request.url.path}" f" HTTP/{request.scope['http_version']}"
    )
    user = user_id or "-"
    message = (
        f"{request.client.host}:{request.client.port} {user} {request_line!r}"
        f" {status_code}"
    )
    return message
