"""Logging configuration"""

import logging
import logging.config
from typing import Any, Dict, List, Optional

import structlog
import uvicorn
from fastapi import Request
from starlette.routing import Match
from structlog.types import Processor


def configure_logging(
    use_mozlog: bool = True, logging_level: str = "INFO", log_sqlalchemy: bool = False
) -> None:
    """Configure Python logging.

    :param use_mozlog: If True, use MozLog format, appropriate for deployments.
        If False, format logs for human consumption.
    :param logging_level: The logging level, such as DEBUG or INFO.
    :param log_sqlalchemy: Include SQLAlchemy engine logs, such as SQL statements
    """
    # Processors used for logs generated by stdlib's logging
    uvicorn_formatters = uvicorn.config.LOGGING_CONFIG["formatters"]

    if use_mozlog:
        structlog_fmt_prep: Processor = structlog.stdlib.render_to_log_kwargs
        structlog_dev_processors: List[Processor] = []
    else:
        structlog_fmt_prep = structlog.stdlib.ProcessorFormatter.wrap_for_formatter
        structlog_dev_processors = [
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
        ]
    logging_config = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "dev_console": {
                "()": structlog.stdlib.ProcessorFormatter,
                "processor": structlog.dev.ConsoleRenderer(colors=True),
                "foreign_pre_chain": structlog_dev_processors,
            },
            "mozlog_json": {
                "()": "dockerflow.logging.JsonLogFormatter",
                "logger_name": "ctms",
            },
            "uvicorn_access": uvicorn_formatters["access"],
            "uvicorn_default": uvicorn_formatters["default"],
        },
        "handlers": {
            "humans": {
                "class": "logging.StreamHandler",
                "formatter": "dev_console",
                "level": "DEBUG",
            },
            "mozlog": {
                "class": "logging.StreamHandler",
                "formatter": "mozlog_json",
                "level": "DEBUG",
            },
            "uvicorn.access": {
                "class": "logging.StreamHandler",
                "formatter": "uvicorn_access",
                "level": "INFO",
            },
            "uvicorn.default": {
                "class": "logging.StreamHandler",
                "formatter": "uvicorn_default",
                "level": "INFO",
            },
        },
        "loggers": {
            "alembic": {
                "propagate": False,
                "handlers": ["mozlog" if use_mozlog else "humans"],
                "level": logging_level,
            },
            "ctms": {
                "propagate": False,
                "handlers": ["mozlog" if use_mozlog else "humans"],
                "level": logging_level,
            },
            "uvicorn": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level,
                "propagate": False,
            },
            "uvicorn.error": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level,
                "propagate": False,
            },
            "uvicorn.access": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.access"],
                "level": "WARNING",  # was INFO, but duplicates ctms.web
                "propagate": False,
            },
            "sqlalchemy.engine": {
                "handlers": ["mozlog" if use_mozlog else "uvicorn.default"],
                "level": logging_level if log_sqlalchemy else "WARNING",
                "propagate": False,
            },
        },
        "root": {
            "handlers": ["mozlog" if use_mozlog else "humans"],
            "level": "WARNING",
        },
    }
    logging.config.dictConfig(logging_config)

    structlog_processors: List[Processor] = [structlog.stdlib.filter_by_level]
    structlog_processors.extend(structlog_dev_processors)
    structlog_processors.extend(
        [
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog_fmt_prep,
        ]
    )
    structlog.configure(
        processors=structlog_processors,
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )


def context_from_request(request: Request) -> Dict:
    """Extract data from a log request."""
    host = None
    if request.client:
        host = request.client.host
    context: Dict[str, Any] = {
        "trivial": False,  # For filtering in papertrail, place early in log
        "client_host": host,
        "method": request.method,
        "path": request.url.path,
    }

    # Determine the path template, like "/ctms/{email_id}"
    for route in request.app.routes:
        match, _ = route.matches(request.scope)
        if match == Match.FULL:
            context["path_template"] = str(route.path)
            break

    if request.path_params:
        context["path_params"] = request.path_params

    # Process headers, omitting security-sensitive values
    headers = {}
    for header_name, header_value in request.headers.items():
        if header_name in {"cookie", "authorization"}:
            headers[header_name] = "[OMITTED]"
        else:
            headers[header_name] = header_value
    if headers:
        context["headers"] = headers

    # Process queries, removing personally-identifiable info
    query = {}
    for query_name, query_value in request.query_params.items():
        if query_name in {"primary_email", "fxa_primary_email"}:
            query[query_name] = "[OMITTED]"
        else:
            query[query_name] = query_value
    if query:
        context["query"] = query

    return context


def get_log_line(
    request: Request, status_code: int, user_id: Optional[str] = None
) -> str:
    """
    Create a log line for a web request

    This is based on the uvicorn log format, but doesn't match exactly.
    Our log looks uses repr, which surrounds the request line with single quotes:

    172.18.0.1:63750 - 'GET /openapi.json HTTP/1.1' 200

    The uvicorn format uses double quotes:

    172.18.0.1:63750 - "GET /openapi.json HTTP/1.1" 200
    """
    request_line = (
        f"{request.method} {request.url.path}" f" HTTP/{request.scope['http_version']}"
    )
    user = user_id or "-"
    host, port = None, None
    if request.client:
        host, port = request.client
    message = f"{host}:{port} {user} {request_line!r}" f" {status_code}"
    return message
